function [vertices,stats,vertex_movements] =...
	ode_solver_farhadifar(cells,vertices,boundary_element,boundary_force_constants,cell_growth_logical,...
	cell_growth_Dpp_dependent,delta_t,FEM_nodes_concentration,mean_edge_length,...
	no_growth_time,ode_solver_type,stats,tension_anisotropy_factor,time,viscosity)
% could we not just put vertex_movements into the vertices structure?

if ode_solver_type == 1
        
	% for the forward euler we just use UpdatePos to do everything - it
	% will overwrite the old vertices.position vector and calculate
	% everything else
	
	[vertices.position,vertex_movements,current_total_area_force,...
		current_total_perimeter_force,current_total_tension_force,current_total_force] =...
		UpdatePosFarhadifar(cells.vertices,vertices.position,boundary_element,cells.area,...
		cells.perimeter,vertices.no_cells,delta_t,cells.target_area,...
		cells.force_constants.area,cells.force_constants.perimeter,...
		cells.force_constants.tension);
        
elseif ode_solver_type == 2
	
	% for the runge-kutta (RK) method we don't actually overwrite the
	% vertices.position vector when we call UpdatePos. we are instead interested 
	% in the particular vertex_movements generated by a certain input. we then sum  
	% these in a particular way at the end. we calculate the total forces acting the
	% first time we call UpdatePos (i.e. during the calculation of a), as this uses 
	% current values of the vertex positions and time.
	
        [~,angle_deviations,RK_vertex_movements_a,current_total_area_force,...
            current_total_boundary_deformation_force,...
            current_total_boundary_edge_force,current_total_deformation_force,...
            current_total_elongation_force,current_total_perimeter_force,...
            current_total_tension_force,current_total_force] =...
            UpdatePos(cells.vertices,vertices.position,boundary_element,cells.area,...
            cells.perimeter,cells.volume,vertices.no_cells,delta_t,cells.edge_lengths,...
            mean_edge_length,cells.target_area,tension_anisotropy_factor,viscosity,...
            cells.force_constants.area,boundary_force_constants.deformation,...
            boundary_force_constants.edge,cells.force_constants.deformation,...
            cells.force_constants.elongation,cells.force_constants.perimeter,...
            cells.force_constants.tension);
        
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		
		vertex_positions_for_b = vertices.position + RK_vertex_movements_a/2;
		
		% we need to input various cell fields into the calculation for b,
		% using vertex_positions_for_b as the basis. e.g. we need to
		% know the areas of all the cells using
		% vertex_positions_for_b rather than vertices.position. we
		% must also use time+delta_t/2 to calculate the cell volumes. this
		% data is to be stored in cells_for_b. it is necessary to create
		% these structures as we don't want to actually change cells during
		% this loop.
		RK_cells_for_b = cells;
        
        [RK_cells_for_b.area,RK_cells_for_b.perimeter,RK_cells_for_b.edge_length] =...
            CalculateCellAreas(RK_cells_for_b.vertices,vertex_positions_for_b);
        
		array_sizes = size(vertices.position,1);
		
        RK_cells_for_b = cell_volume_growth(array_sizes,cell_growth_logical,...
            cell_growth_Dpp_dependent,RK_cells_for_b,delta_t/2,...
            FEM_nodes_concentration,no_growth_time,time);
        
		% is there any point writing a simplified version of UpdatePos to
		% do this? it probably wouldn't save much time relatively in the
		% big scheme of things but might be a bit neater
        [~,~,RK_vertex_movements_b] = UpdatePos(RK_cells_for_b.vertices,...
			vertex_positions_for_b,boundary_element,RK_cells_for_b.area,...
            RK_cells_for_b.perimeter,RK_cells_for_b.volume,vertices.no_cells,...
			delta_t,RK_cells_for_b.edge_lengths,mean_edge_length,...
            cells.target_area,tension_anisotropy_factor,viscosity,...
            cells.force_constants.area,boundary_force_constants.deformation,...
            boundary_force_constants.edge,cells.force_constants.deformation,...
            cells.force_constants.elongation,cells.force_constants.perimeter,...
            cells.force_constants.tension);
        
        
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		
		vertex_positions_for_c = vertices.position+RK_vertex_movements_b/2;
        
		RK_cells_for_c = cells;
		
		[RK_cells_for_c.area,RK_cells_for_c.perimeter,RK_cells_for_c.edge_length] =...
			CalculateCellAreas(RK_cells_for_c.vertices,vertex_positions_for_c);
		
		% there is clearly some redundancy here as the volumes for thee
		% cells for c should be the same as that for b. for simplicity we
		% keep this in for now.
		RK_cells_for_c = cell_volume_growth(array_sizes,cell_growth_logical,...
			cell_growth_Dpp_dependent,RK_cells_for_c,delta_t/2,FEM_nodes_concentration,...
			no_growth_time,time);
        
        [~,~,RK_vertex_movements_c] = UpdatePos(RK_cells_for_c.vertices,...
			vertex_positions_for_c,boundary_element,RK_cells_for_c.area,...
            RK_cells_for_c.perimeter,RK_cells_for_c.volume,vertices.no_cells,...
			delta_t,RK_cells_for_c.edge_lengths,mean_edge_length,...
            cells.target_area,tension_anisotropy_factor,viscosity,...
            cells.force_constants.area,boundary_force_constants.deformation,...
            boundary_force_constants.edge,cells.force_constants.deformation,...
            cells.force_constants.elongation,cells.force_constants.perimeter,...
            cells.force_constants.tension);
        
        
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		
		vertex_positions_for_d = vertices.position+RK_vertex_movements_c;
		
		RK_cells_for_d = cells;
        
        [RK_cells_for_d.area,RK_cells_for_d.perimeter,RK_cells_for_d.edge_length] =...
            CalculateCellAreas(cells.vertices,vertex_positions_for_d);
        
        RK_cells_for_d = cell_volume_growth(array_sizes,cell_growth_logical,...
            cell_growth_Dpp_dependent,RK_cells_for_d,delta_t,FEM_nodes_concentration,...
            no_growth_time,time);
        
        [~,~,RK_vertex_movements_d] = UpdatePos(RK_cells_for_d.vertices,...
			vertex_positions_for_d,boundary_element,RK_cells_for_d.area,...
            RK_cells_for_d.perimeter,RK_cells_for_d.volume,vertices.no_cells,...
			delta_t,RK_cells_for_d.edge_lengths,mean_edge_length,...
            cells.target_area,tension_anisotropy_factor,viscosity,...
            cells.force_constants.area,boundary_force_constants.deformation,...
            boundary_force_constants.edge,cells.force_constants.deformation,...
            cells.force_constants.elongation,cells.force_constants.perimeter,...
            cells.force_constants.tension);
		
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        
        vertex_movements = 1/6*(RK_vertex_movements_a+2*RK_vertex_movements_b+...
			2*RK_vertex_movements_c+RK_vertex_movements_d);
        
        vertices.position = vertices.position + vertex_movements;

else
	
	error('invalid ode_solver_type');
	
end

if stats.this_iteration_logical
	
	stats.total_boundary_vertices(stats.counter) =...
		length(boundary_element);
	
	stats.total_area_force(stats.counter) = current_total_area_force;
% 	stats.total_boundary_deformation_force(stats.counter) =...
% 		current_total_boundary_deformation_force;
% 	stats.total_boundary_edge_force(stats.counter) =...
% 		current_total_boundary_edge_force;
% 	stats.total_deformation_force(stats.counter) =...
% 		current_total_deformation_force;
% 	stats.total_elongation_force(stats.counter) =...
% 		current_total_elongation_force;
	stats.total_perimeter_force(stats.counter) =...
		current_total_perimeter_force;
	stats.total_tension_force(stats.counter) = current_total_tension_force;
	stats.total_force(stats.counter) = current_total_force;
	
end